#!/usr/bin/env python
# encoding: UTF-8
"""Deploy current versions of all tools within KS_TOOLS.

Pulls the master branch from each repo's origin, cleans up any orphaned *.pyc
files, and compiles any new *.py files.

"""

import optparse
import os
import py_compile
import sys
import time
from subprocess import call, check_call

try:
    from subprocess import check_output, CalledProcessError
    
except:
    
    import subprocess
    
    class CalledProcessError(ValueError):
        pass
    
    def check_output(cmd, **kwargs):
        kwargs['stdout'] = subprocess.PIPE
        proc = subprocess.Popen(cmd, **kwargs)
        out, _ = proc.communicate()
        status = proc.wait()
        if status:
            err = CalledProcessError('Command %r returned non-zero exit status %r' % (cmd, status))
            err.returncode = status
            err.cmd = cmd
            err.output = out
            raise err
        return out
    

CSI = '\x1b['
_colours = dict(
    black=0,
    red=1,
    green=2,
    yellow=3,
    blue=4,
    magenta=5,
    cyan=7,
    white=7,
)

def colour(message, fg=None, bg=None, bright=False, reset=False):
    parts = []
    if fg is not None:
        parts.extend((CSI, '3', str(_colours[fg]), 'm'))
    if bg is not None:
        parts.extend((CSI, '4', str(_colours[bg]), 'm'))
    if bright:
        parts.extend((CSI, '1m'))
    parts.append(message)
    if reset:
        parts.extend((CSI, '0m'))
    return ''.join(parts)


def git_call(repo, *args, **kwargs):
    kwargs.setdefault('cwd', os.path.dirname(repo))
    cmd = ['git', '--git-dir', repo] 
    cmd.extend(args)
    return check_call(cmd, **kwargs)
    
def git_output(repo, *args, **kwargs):
    kwargs.setdefault('cwd', os.path.dirname(repo))
    cmd = ['git', '--git-dir', repo] 
    cmd.extend(args)
    return check_output(cmd, **kwargs)


def compile_bytecode(fullname, debug=False, force=False, quiet=False):
    """Compile bytecode for given file.
    
    Lifted from compile all since compileall.compile_file is not availible
    until Python 2.6.
    
    """
    
    cfile = fullname + (__debug__ and 'c' or 'o')
    ftime = os.stat(fullname).st_mtime
    try:
        ctime = os.stat(cfile).st_mtime
    except os.error:
        ctime = 0
    
    # Pull future times back to reality.
    if ftime > time.time():
        print 'Future mtime on', fullname
        os.utime(fullname, None)
    
    if (ctime > ftime) and not force:
        return
    
    if not quiet:
        print 'Compiling', fullname, '...'
    
    try:
        py_compile.compile(fullname, cfile, None, True)
    
    except KeyboardInterrupt:
        raise KeyboardInterrupt
    
    except py_compile.PyCompileError, err:
        if quiet:
            print 'Compiling', fullname, '...'
        print err.msg
    
    except IOError, e:
        print colour("ERROR:", bg='red', reset=True), e
    

optparser = optparse.OptionParser()
optparser.add_option("--force", dest="force", action="store_true", default=False)
optparser.add_option("--clean", dest="clean", action="store_true", default=False)
optparser.add_option("--reset", dest="reset", action="store_true", default=False)
optparser.add_option("--nopyc", dest="nopyc", action="store_true", default=False)
optparser.add_option("--nomake", dest="nomake", action="store_true", default=False)
optparser.add_option("--nosubmodules", dest="nosubmodules", action="store_true", default=False)
opts, args = optparser.parse_args()


# Lookup location of tools.
ks_tools = os.environ['KS_TOOLS']

# Allow the user to specify which tools to deploy.
if len(sys.argv) > 1:
    if sys.argv[1:] == ['.']:
        tool_names = [os.path.basename(os.getcwd())]
    else:
        tool_names = sys.argv[1:]
else:
    tool_names = sorted(os.listdir(ks_tools))


for tool_name in tool_names:
    
    if tool_name.startswith('.'):
        continue
    
    print '==>', colour(tool_name, fg='blue', reset=True)
    
    tool_path = os.path.join(ks_tools, tool_name)
    repo = os.path.join(tool_path, '.git')
    if not os.path.exists(repo):
        print
        print colour('ERROR: Not a git repo.', fg='red')
        continue
    
    # Get current commit to see if we need to do the cleanups later.
    current_head = git_output(repo, 'rev-parse', '--verify', 'HEAD').strip()
    
    # Get the new commits.
    git_call(repo, 'fetch', 'origin')
    
    # Don't bother doing the merge or cleanups if we wouldn't move anyways.
    origin_master = git_output(repo, 'rev-parse', '--verify', 'origin/master').strip()
    if not opts.force and origin_master == current_head:
        continue
    
    # Do the reset or merge.
    if opts.reset:
        try:
            git_call(repo, 'reset', '--hard', 'origin/master')
        except CalledProcessError:
            print colour('ERROR: Git error during reset.', fg='red', reset=True)
            continue
    else:
        try:
            git_call(repo, 'merge', '--ff-only', 'origin/master')
        except CalledProcessError:
            print colour('ERROR: Git error during fast-forward (merge).', fg='red', reset=True)
            continue
    
    # Update and submodules.
    if not opts.nosubmodules:
        try:
            git_call(repo, 'submodule', 'update', '--init', '--recursive')
        except CalledProcessError:
            print colour('ERROR: Git error during submodule update.', fg='red', reset=True)
            continue
    
    # Clean up temporary files we may have made, except for *.pyc since we will
    # do that ourselves, and documentation builds since that is very anoying.
    # The exclude logic is quite backwards from expected.
    if opts.clean:
        git_call(repo, 'clean', '-dXf')
        if not opts.nosubmodules:
            git_call(repo, 'submodule', 'foreach', '--recursive', 'git', 'clean', '-dXf')
    
    # Run a top-level Makefile if it exists.
    if not opts.nomake and os.path.exists(os.path.join(tool_path, 'Makefile')):
        check_call(['make', '-j4'], cwd=tool_path)
    
    # Find all Python source code and compile it to bytecode while removing
    # orphaned bytecode.
    if not opts.nopyc:
        for dir_path, dir_names, file_names in os.walk(tool_path):
            visited = set()
            for file_name in file_names:
            
                # We only care about Python source code (for now).
                if file_name.startswith('.'):
                    continue
                if os.path.splitext(file_name)[1] not in ('.py', '.pyc'):
                    continue
                
                # Normalize to the source file.
                file_name = file_name.rstrip('c')
                
                # Only deal with one of the source or compiled.
                if file_name in visited:
                    continue
                visited.add(file_name)
                
                # Compile bytecode if the file exists, and remove bytecode if
                # the file does not.
                file_path = os.path.join(dir_path, file_name)
                if os.path.exists(file_path):
                    compile_bytecode(file_path)
                elif os.path.exists(file_path + 'c'):
                    print 'Removing', file_path + 'c'
                    os.unlink(file_path + 'c')
    
